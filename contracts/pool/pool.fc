#include "opcodes.fc";
#include "errors.fc";
#include "../common/stdlib.fc";
#include "../common/opcodes.fc";
#include "../common/utils.fc";

(slice) load_data() inline_ref {
    slice data = get_data().begin_parse();

    return (
        data~load_msg_addr(),   ;; router address
        data~load_msg_addr(),   ;; asset 0 address
        data~load_msg_addr(),   ;; asset 1 address
        data~load_uint(8)       ;; pool fee
    );
}

() save_data(slice router_addr, slice asset_0_addr, slice asset_1_addr, int fee) impure inline_ref {
    cell data = begin_cell()
                    .store_slice(router_addr)
                    .store_slice(asset_0_addr)
                    .store_slice(asset_1_addr)
                    .store_uint(fee, 8)
                .end_cell();

    set_data(data);
}

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    var cs = in_msg_full.begin_parse();  
    var flags = cs~load_uint(4); ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool

    if (flags & 1) {
        return (); ;; ignore all bounced messages
    }

    slice sender_address = cs~load_msg_addr();
    (_, int sender_address_hash) = parse_std_addr(sender_address);

    throw_if(error::empty_msg_body, in_msg_body.slice_empty?());

    (int op, int query_id) = in_msg_body~load_body_header();

    if (op == op::swap) {
        return ();
    }

    if (op == op::add_liquidity) {
        return ();
    }

    if (op == op::withdraw_liquidity) {
        return ();
    }

    throw(0xffff);
}